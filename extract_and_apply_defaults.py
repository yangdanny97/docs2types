import ast
import os
import sys
import importlib
import inspect
import re
import libcst as cst

root = ""
# the keys the part of the parameter's docstring that occurs after the word "default"
# the values are generated by chatGPT from the keys
# the ones that are vague or obviously wrong are commented out so we will not insert them
default_type_map = {
    # 'is ("_x", "_y")': 'tuple[Literal["x"], Literal["y"]]',
    "'average'": "Literal['average']",
    # 'end': '?',  # probably a variable
    # 'object': 'type',
    'is True': 'True',
    'None, provide an encoding for str': 'None',
    '10': 'Literal[10]',
    "'D'": "Literal['D']",
    "'red'": "Literal['red']",
    "'left'": "Literal['left']",
    # 'True if ax is None else False': '?',
    "'start_day'": "Literal['start_day']",
    "'utf8'": "Literal['utf8']",
    "'fixed'": "Literal['fixed']",
    'False': 'Literal[False]',
    "'infer'": "Literal['infer']",
    '-1': 'Literal[-1]',
    "'lxml'": "Literal['lxml']",
    "'any'": "Literal['any']",
    "'auto'": "Literal['auto']",
    "'yellow'": "Literal['yellow']",
    "'zlib'": "Literal['zlib']",
    '50': 'Literal[50]',
    "'S' (start)": "Literal['S']",  # assuming just 'S'
    "'strict'": "Literal['strict']",
    '"both"': "Literal['both']",
    'None (English locale)': 'None',
    '""': "Literal['']",
    # 'Warning': 'type',  # refers to a class, likely
    'is None': 'None',
    '0.5 (50% quantile)': 'Literal[0.5]',
    "'C'": "Literal['C']",
    "'fail'": "Literal['fail']",
    # 'frequency of PeriodIndex': '?',
    "'Categorical'": "Literal['Categorical']",
    "'keep'": "Literal['keep']",
    "'pandas'": "Literal['pandas']",
    "'inner'": "Literal['inner']",
    '0.05': 'Literal[0.05]',
    "'pad'": "Literal['pad']",
    '3': 'Literal[3]',
    'None)': 'None',
    "``'numba'``": "Literal['numba']",
    "'right'": "Literal['right']",
    "'./\\*'": "Literal['./\\*']",
    # '_default_hash_key': '?',  # variable
    'False)': 'Literal[False]',
    "'last'": "Literal['last']",
    '1e-8': 'Literal[1e-8]',
    'None (NaN)': 'None',
    "'DataFrame'": "Literal['DataFrame']",
    'False, optional': 'Literal[False]',
    '"."': "Literal['.']",
    # 'np.nan': 'float',
    "'E'": "Literal['E']",
    "'numpy_nullable'": "Literal['numpy_nullable']",
    "'outer'": "Literal['outer']",
    "('self', 'other')": 'tuple[str, str]',
    "is 'fixed'": "Literal['fixed']",
    "'end'": "Literal['end']",
    'bool': 'type',
    "'axes'": "Literal['axes']",
    "'_'": "Literal['_']",
    '-2': 'Literal[-2]',
    # 'last level': '?',
    "'Attributes'": "Literal['Attributes']",
    '500': 'Literal[500]',
    "'Index'": "Literal['Index']",
    '"mean"': "Literal['mean']",
    "'columns'": "Literal['columns']",
    "'Sheet1'": "Literal['Sheet1']",
    "'start'": "Literal['start']",
    "'IntervalArray'": "Literal['IntervalArray']",
    "'quicksort'": "Literal['quicksort']",
    "``'\\t'``": "Literal['\\t']",
    "'utf-8'": "Literal['utf-8']",
    '-1 (last level)': 'Literal[-1]',
    "'numexpr'": "Literal['numexpr']",
    # 'lib.no_default': '?',
    "'mid'": "Literal['mid']",
    '"UTF-8"': "Literal['UTF-8']",
    'True': 'Literal[True]',
    '0': 'Literal[0]',
    "'equiv'": "Literal['equiv']",
    'None None': 'None',
    "'inf'": "Literal['inf']",
    "'single'": "Literal['single']",
    "'\\\\d+'": "Literal['\\\\d+']",
    "'a'": "Literal['a']",
    "'T'": "Literal['T']",
    'is True,': 'Literal[True]',
    "'.'": "Literal['.']",
    "'numpy array'": "Literal['numpy array']",
    "'first'": "Literal['first']",
    "'ignore'": "Literal['ignore']",
    '"always"': "Literal['always']",
    "'value'": "Literal['value']",
    'None': 'None',
    "'All'": "Literal['All']",
    "'ExtensionArray'": "Literal['ExtensionArray']",
    '5': 'Literal[5]',
    '1': 'Literal[1]',
    '1e-5': 'Literal[1e-5]',
    "''": "Literal['']",
    '"/"': "Literal['/']",
    '100': 'Literal[100]',
    '`None`': 'None',
    "'raise'": "Literal['raise']",
}


defaults = set()

# Get the docstring that appears on the same line as the parameter description
# If it contains "default", return the part that appears after it
def extract_param_default(docstring: str, param: str) -> str | None:
    if not docstring:
        return None
    lines = docstring.splitlines()
    try:
        start = lines.index("Parameters")
    except ValueError:
        return None
    # Look for "----------" after "Parameters"
    for i in range(start + 1, len(lines)):
        if re.match(r'^-+$', lines[i].strip()):
            param_start = i + 1
            break
    else:
        return None
    param_pattern = re.compile(rf'^{re.escape(param)}\s*:\s*(.+)$')
    for i in range(param_start, len(lines)):
        line = lines[i].strip()
        if not line:
            continue
        if re.match(r'^[A-Za-z_][A-Za-z0-9_]*\s*:', line):  # new param starts
            match = param_pattern.match(line)
            if match:
                matched = match.group(1).strip()
                if "default is " in matched:
                    return matched.split("default is ")[-1]
                if "Default is " in matched:
                    return matched.split("Default is ")[-1]
                if "defaults to " in matched:
                    return matched.split("defaults to ")[-1]
                if "Defaults to " in matched:
                    return matched.split("Defaults to ")[-1]
                if "default " in matched:
                    return matched.split("default ")[-1]
                if "Default " in matched:
                    return matched.split("Default ")[-1]
                return None
        elif line.startswith(('See Also', 'Notes', 'Examples')):
            break  # past parameter section
    return None


# LibCST transformation that adds a default value to a given parameter in a given file
class ParameterDefaultAdder(cst.CSTTransformer):
    def __init__(self, func_or_method: str, param_name: str, default_str: str):
        self.param_name = param_name
        self.default = cst.parse_expression(default_str)
        if '.' in func_or_method:
            self.class_name, self.func_name = func_or_method.split('.')
        else:
            self.class_name = None
            self.func_name = func_or_method
        self.inside_target_class = self.class_name is None  # True for top-level functions

    def visit_ClassDef(self, node: cst.ClassDef):
        if self.class_name and node.name.value == self.class_name:
            self.inside_target_class = True

    def leave_ClassDef(self, original_node, node: cst.ClassDef):
        if self.class_name and node.name.value == self.class_name:
            self.inside_target_class = False
        return node

    def leave_FunctionDef(
        self, original_node: cst.FunctionDef, updated_node: cst.FunctionDef
    ) -> cst.FunctionDef:
        if not self.inside_target_class:
            return updated_node
        if original_node.name.value != self.func_name:
            return updated_node
        new_params = []
        for param in updated_node.params.params:
            if param.name.value == self.param_name:
                new_param = param.with_changes(default=self.default)
                new_params.append(new_param)
            else:
                new_params.append(param)
        return updated_node.with_changes(
            params=updated_node.params.with_changes(params=new_params)
        )


# This function applies a type annotation to a parameter
def add_default_to_parameter(filename, function, parameter, annotation) -> None:
    with open(filename, "r") as f:
        code = f.read()
    module = cst.parse_module(code)
    transformer = ParameterDefaultAdder(function, parameter, annotation)
    modified_module = module.visit(transformer)
    with open(filename, "w") as f:
        f.write(modified_module.code)


# Extract the docstring of a given function/method in a given module
def get_docstring(mod: str, func: str) -> str | None:
    try:
        module = importlib.import_module(mod)
        if '.' in func:
            cls_name, method_name = func.split('.', 1)
            cls = getattr(module, cls_name, None)
            if cls is None:
                return None
            obj = getattr(cls, method_name, None)
        else:
            obj = getattr(module, func, None)
        if obj is None:
            return None
        return inspect.getdoc(obj)
    except Exception as e:
        print(e)
        return None


def get_module_path(root: str, file_path: str) -> str:
    rel_path = os.path.relpath(file_path, root)
    no_ext = os.path.splitext(rel_path)[0]
    return no_ext.replace(os.path.sep, '.')


# Get any parameters from the stub that have a default of `...`
def get_ellipsis_params(func_def: ast.FunctionDef):
    args = func_def.args
    num_defaults = len(args.defaults)
    ellipsis_params = []

    # Defaults align to the last N positional args
    for arg, default in zip(args.args[-num_defaults:], args.defaults):
        if isinstance(default, ast.Constant) and default.value is Ellipsis:
            ellipsis_params.append(arg.arg)

    # Similarly check kwonlyargs
    for kwarg, default in zip(args.kwonlyargs, args.kw_defaults):
        if isinstance(default, ast.Constant) and default.value is Ellipsis:
            ellipsis_params.append(kwarg.arg)

    return ellipsis_params


# For any parameters in the stub with default `...`, try to guess the type from the docstring
def process_function(module: str, class_name: str | None, func_node: ast.FunctionDef, pkg_name) -> None:
    if func_node.name.startswith('__') and func_node.name.endswith('__'):
        return
    func_name = f"{class_name}.{func_node.name}" if class_name else func_node.name
    docstring = get_docstring(f"{pkg_name}.{module}", func_name)
    if docstring is None:
        return
    global defaults
    for arg in get_ellipsis_params(func_node):
        if arg in {'self', 'cls'}:
            continue
        arg_default = extract_param_default(docstring, arg)
        if arg_default is None:
            continue
        path = root + "/" + module.replace(".", "/") + ".pyi"
        arg_default = default_type_map.get(arg_default)
        if arg_default is None:
            continue
        add_default_to_parameter(path, func_name, arg, arg_default)
        defaults.add(arg_default)


def is_overload(func: ast.FunctionDef) -> bool:
    for decorator in func.decorator_list:
        if isinstance(decorator, ast.Name) and decorator.id == 'overload':
            return True
        if isinstance(decorator, ast.Attribute) and decorator.attr == 'overload':
            return True
    return False


def process_file(root: str, file_path: str, pkg_name) -> None:
    module = get_module_path(root, file_path)
    with open(file_path, "r", encoding="utf-8") as f:
        try:
            tree = ast.parse(f.read(), filename=file_path)
        except SyntaxError:
            return
    for node in tree.body:
        if isinstance(node, ast.FunctionDef):
            if is_overload(node):
                continue
            process_function(module, None, node, pkg_name)
        elif isinstance(node, ast.ClassDef):
            for item in node.body:
                if isinstance(item, ast.FunctionDef):
                    if is_overload(item):
                        continue
                    process_function(module, node.name, item, pkg_name)


def walk_directory(root: str, pkg_name: str) -> None:
    for dirpath, _, filenames in os.walk(root):
        for filename in filenames:
            if filename.endswith(".pyi"):
                process_file(root, os.path.join(dirpath, filename), pkg_name)


# Instructions:
# 1. clone pandas-stubs
# 2. install pandas
# 3. python3 extract_and_apply_defaults.py ./pandas-stubs/pandas-stubs pandas
if __name__ == "__main__":
    root = sys.argv[1]
    walk_directory(sys.argv[1], sys.argv[2])
