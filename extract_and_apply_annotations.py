import ast
import os
import sys
import importlib
import inspect
import re
import libcst as cst


root = ""

# this was generated by chatGPT and manually edited/cleaned up
# if the annotation looks tricky or unclear, it's commented out
type_map = {
    "bool or None, default None": "bool | None",
    "`Categorical`": "pandas.Categorical",
    "scipy.sparse.sp_matrix": "scipy.sparse.spmatrix",
    # "the object to write to the clipboard": "?",
    "str, default frequency of PeriodIndex": "str",
    "structured ndarray, sequence of tuples or dicts, or DataFrame": "np.ndarray | Sequence[tuple] | Sequence[dict] | pandas.DataFrame",
    "a hashable object": "Hashable",
    "list of int or list of str": "list[int] | list[str]",
    "Categorical": "pandas.Categorical",
    "DatetimeIndex, TimedeltaIndex, or Series": "pandas.DatetimeIndex | pandas.TimedeltaIndex | pandas.Series",
    # "Scope": "?",
    # "label or sequence of labels": "Hashable | Sequence[Hashable]",
    "DateOffset or str": "pandas.DateOffset | str",
    "array-like or scalar": "ArrayLike | Scalar",
    "pandas.Index": "pandas.Index",
    "scalar, dict, Series": "Scalar | dict | pandas.Series",
    "scalar, default None": "Scalar | None",
    "bool, default True": "bool",
    "object": "object",
    "{'backfill', 'bfill', 'pad', 'ffill', None}, default None": "Literal['backfill', 'bfill', 'pad', 'ffill'] | None",
    "int or array of ints": "int | ArrayLike[int]",
    "int, default 1": "int",
    # "label or list of labels": "Hashable | list[Hashable]",
    "date or array-like of dates": "datetime.date | ArrayLike[datetime.date]",
    # "ExtensionArray or ndarray": "pandas.api.extensions.ExtensionArray | np.ndarray",
    # "Series or scalar value": "pandas.Series | Scalar",
    # "pd.Index": "pandas.Index",
    "data type": "dtype | str | type",
    "object, optional": "object | None",
    "str, optional": "str | None",
    # "the maximum of this `Categorical`, NA if array is empty": "?",
    "label, default None": "Hashable | None",
    "Examples": None,
    "PeriodArray/PeriodIndex": "pandas.PeriodArray | pandas.PeriodIndex",
    "list of str to be drawn as titles of left DataFrames": "list[str]",
    "{'left', 'right'}": "Literal['left', 'right']",
    "np.ndarray or pandas.api.extensions.ExtensionArray": "np.ndarray | pandas.api.extensions.ExtensionArray",
    "slice": "slice",
    "tuple": "tuple[Any, ...]",
    "numpy.dtype": "np.dtype",
    "function, str, list or dict": "Callable | str | list | dict",
    "array-like, list or scalar": "ArrayLike | list | Scalar",
    "list-like, dict-like or callable": "ListLike | DictLike | Callable",
    "int or level name, default None": "int | str | None",
    "category or list of categories": "Hashable | list[Hashable]",
    "str or dtype": "str | dtype",
    "str, np.dtype, or ExtensionDtype, optional": "str | np.dtype | pandas.api.extensions.ExtensionDtype | None",
    "dtype or None, default None": "dtype | None",
    "int or hashable, optional": "int | Hashable | None",
    "ndarray or ExtensionArray": "np.ndarray | pandas.api.extensions.ExtensionArray",
    "Categorical or None": "pandas.Categorical | None",
    "label or list of label or dict-like for MultiIndex": "Hashable | list[Hashable] | Mapping",
    "float": "float",
    "an iterable": "Iterable",
    "bool array-like with the same length as self": "ArrayLike[bool]",
    "Index or list/tuple of indices": "pandas.Index | list | tuple",
    "ndarray[object]": "np.ndarray[object]",
    "str or Offset": "str | pandas.tseries.offsets.DateOffset",
    "int/level name or list thereof, optional": "int | str | list[int | str] | None",
    "np.ndarray[np.intp]": "np.ndarray[np.intp]",
    "scipy.sparse.spmatrix": "scipy.sparse.spmatrix",
    "array": "np.ndarray",
    "np.ndarray or ExtensionArray": "np.ndarray | pandas.api.extensions.ExtensionArray",
    "DataFrame": "pandas.DataFrame",
    "scalar, or array-like, default None": "Scalar | ArrayLike | None",
    "category or list-like of category": "Hashable | ListLike[Hashable]",
    "scalar, Series/DataFrame, or callable": "Scalar | pandas.Series | pandas.DataFrame | Callable",
    "Index": "pandas.Index",
    "array-like or scalar value": "ArrayLike | Scalar",
    "{None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional": "Literal['pad', 'ffill', 'backfill', 'bfill', 'nearest'] | None",
    "IntervalArray": "pandas.arrays.IntervalArray",
    "Index, optional": "pandas.Index | None",
    "array: numpy.ndarray or ExtensionArray": "np.ndarray | pandas.api.extensions.ExtensionArray",
    "pd.MultiIndex": "pandas.MultiIndex",
    "ExtensionArray or np.ndarray": "pandas.api.extensions.ExtensionArray | np.ndarray",
    "pandas.Categorical or pandas.Index": "pandas.Categorical | pandas.Index",
    "MultiIndex": "pandas.MultiIndex",
    "Container (e.g. list-like or mapping)": "Container",
    "sequence, optional": "Sequence | None",
    "list of ndarrays": "list[np.ndarray]",
    "list": "list",
    "{'left', 'right', 'both', 'neither'}": "Literal['left', 'right', 'both', 'neither']",
    "Index or None": "pandas.Index | None",
    "int or list of int": "int | list[int]",
    "list of DataFrames before operation is applied": "list[pandas.DataFrame]",
    ":class:`Categorical`or :class:`categoricalIndex`": "pandas.Categorical | pandas.CategoricalIndex",
    "array-like (1-dimensional)": "ArrayLike",
    "sequence, default None": "Sequence | None",
    "numpy.ndarray or pandas.api.extensions.ExtensionArray": "np.ndarray | pandas.api.extensions.ExtensionArray",
    "label or tuple, can be partial. Default None": "Hashable | tuple | None",
    "list-like of list-likes": "ListLike[ListLike]",
    # "optional": "?",
    "Series": "pandas.Series",
    "bool or :attr:`pandas.NA`": "bool | pandas.NA",
    "int, optional": "int | None",
    "scalar": "Scalar",
    "{None, 'ignore'}": "Literal['ignore'] | None",
    "str, list of fields, array-like": "str | list[str] | ArrayLike",
    "object, defaults to index.name": "object",
    "Index-like": "pandas.Index | IndexLike",
    "scalar, optional": "Scalar | None",
    "Any": "Any",
    "scalar, sequence, Series, or DataFrame": "Scalar | Sequence | pandas.Series | pandas.DataFrame",
    # "term_type": "?",
    "set or list-like": "set | ListLike",
    "str, DateOffset, dateutil.relativedelta": "str | pandas.DateOffset | dateutil.relativedelta.relativedelta",
    "Same type as self": "Self",
    # "array of ints or int": "np.ndarray[int] | int",
    # "type": "type",
    "int, defaults None": "int | None",
    "Index or MultiIndex": "pandas.Index | pandas.MultiIndex",
    "{None, 'C', 'F', 'A', 'K'}, default 'C'": "Literal['C', 'F', 'A', 'K'] | None",
    "any, optional": "Any | None",
    "list-like, Index": "ListLike | pandas.Index",
    "path-like, file-like, or ExcelWriter object": "os.PathLike | IO | pandas.ExcelWriter",
    "description: `DataFrame`": "pandas.DataFrame",
    "int or float, optional": "int | float | None",
    "dtype, optional": "dtype | None",
    "int or array of int": "int | ArrayLike[int]",
    # "label, slice, list, mask or a sequence of such": "Hashable | slice | list | Series[bool] | Sequence",
    "dict, Series, callable": "dict | pandas.Series | Callable",
    "new index (of same type and class...etc) or None": "pandas.Index | None",
    "array-like": "ArrayLike",
    "str, default 'pandas'": "str",
    # "join_index, (left_indexer, right_indexer)": "tuple[pandas.Index, tuple[np.ndarray, np.ndarray]]",
    "DatetimeIndex": "pandas.DatetimeIndex",
    "IntervalArray with NA/NaN filled": "pandas.arrays.IntervalArray",
    # "result": "?",
    "one-parameter function or str, optional, default None": "Callable[[Any], Any] | str | None",
    "Index or array-like": "pandas.Index | ArrayLike",
    "sequence or list of sequence": "Sequence | list[Sequence]",
    "Series or Index": "pandas.Series | pandas.Index",
    "tuple[int, int]": "tuple[int, int]",
    "datetime.tzinfo, pytz.tzinfo.BaseTZInfo, dateutil.tz.tz.tzfile, or None": "datetime.tzinfo | pytz.BaseTzInfo | dateutil.tz.tzfile | None",
    "Union[ndarray, Index, ExtensionArray]": "np.ndarray | pandas.Index | pandas.api.extensions.ExtensionArray",
    "Series or DataFrame": "pandas.Series | pandas.DataFrame",
    "int": "int",
    # "DataFrameXchg": "?",
    "scalar, Series or DataFrame": "Scalar | pandas.Series | pandas.DataFrame",
    "matplotlib.AxesSubplot or numpy.ndarray of them": "matplotlib.AxesSubplot | np.ndarray[matplotlib.AxesSubplot]",
    "str, DateOffset or dateutil.relativedelta": "str | pandas.DateOffset | dateutil.relativedelta.relativedelta",
    "None": "None",
    "bool": "bool",
    "str or int, optional": "str | int | None",
    "scipy.sparse.coo_matrix": "scipy.sparse.coo_matrix",
    "DataFrame of operation result": "pandas.DataFrame",
    "Array or Index": "np.ndarray | pandas.Index",
    "array-like or list-like": "ArrayLike | ListLike",
    "pandas.DateOffset, pandas.Timedelta or string, optional": "pandas.DateOffset | pandas.Timedelta | str | None",
    "str or Period, optional": "str | pandas.Period | None",
    "1-D array-like, optional": "ArrayLike | None",
    "bool, default False": "bool",
    # "bytes used": "bytes",
    "tuples: ndarray (if self is IntervalArray) or Index (if self is IntervalIndex)": "np.ndarray[tuple] | pandas.Index",
    "DatetimeArray, DatetimeIndex or Series": "pandas.arrays.DatetimeArray | pandas.DatetimeIndex | pandas.Series",
    # "function, dict, or Series": "Callable | dict | pandas.Series",
    "numpy dtype or pandas type": "np.dtype | pandas.api.types.PandasDtype",
    "datetime.time or str": "datetime.time | str",
    "int, default None": "int | None",
    "callable": "Callable",
    "scalar, array-like": "Scalar | ArrayLike",
    "DeepChainMap": "DeepChainMap",
    "str": "str",
    "np.dtype or ExtensionDtype": "np.dtype | pandas.api.extensions.ExtensionDtype",
    "ExtensionArray": "pandas.api.extensions.ExtensionArray",
    "SparseArray": "pandas.arrays.SparseArray",
    # "function, list of functions, dict, default \"mean\"": "Callable | list[Callable] | dict",
    "pandas.api.extensions.ExtensionArray": "pandas.api.extensions.ExtensionArray",
    "NumPy array": "np.ndarray",
    "Series:": "pandas.Series",
    "numpy.ndarray[bool]": "np.ndarray[bool]",
    # "the minimum of this `Categorical`, NA value if empty": "?",
    "numpy.ndarray": "np.ndarray",
    "np.ndarray[bool]": "np.ndarray[bool]",
    "RangeIndex": "pandas.RangeIndex",
    "list of functions or dict of str: function, optional": "list[Callable] | dict[str, Callable] | None",
    "tuple/list": "tuple | list",
    "scalar, sequence, Series, dict or DataFrame": "Scalar | Sequence | pandas.Series | dict | pandas.DataFrame",
}


# This looks up the type annotation from type_map and removes any pandas-related qualifiers
# on the types
def filter_type_annotation(annotation: str) -> str | None:
    annotation = type_map.get(annotation)
    if annotation is None:
        return None
    parts = annotation.split()
    result = []
    for part in parts:
        if part.startswith("pandas.") or part.startswith("pd."):
            result.append(part.split(".")[-1])
        else:
            result.append(part)
    return " ".join(result)


types = set()


# This libCST applies a type annotation to a function parameter or return
class MethodAnnotator(cst.CSTTransformer):
    def __init__(self, func_or_method: str, param_name: str | None, annotation_str: str):
        self.param_name = param_name
        self.annotation = cst.Annotation(cst.parse_expression(annotation_str))
        if '.' in func_or_method:
            self.class_name, self.func_name = func_or_method.split('.')
        else:
            self.class_name = None
            self.func_name = func_or_method
        self.inside_target_class = self.class_name is None  # True for top-level functions

    def visit_ClassDef(self, node: cst.ClassDef):
        if self.class_name and node.name.value == self.class_name:
            self.inside_target_class = True

    def leave_ClassDef(self, original_node, node: cst.ClassDef):
        if self.class_name and node.name.value == self.class_name:
            self.inside_target_class = False
        return node

    def leave_FunctionDef(
        self, original_node: cst.FunctionDef, updated_node: cst.FunctionDef
    ) -> cst.FunctionDef:
        if not self.inside_target_class:
            return updated_node

        if original_node.name.value != self.func_name:
            return updated_node

        new_params = []
        for param in updated_node.params.params:
            if self.param_name and param.name.value == self.param_name and param.annotation is None:
                new_param = param.with_changes(annotation=self.annotation)
                new_params.append(new_param)
            else:
                new_params.append(param)
        if self.param_name is None:
            updated_node = updated_node.with_changes(returns=self.annotation)
        return updated_node.with_changes(
            params=updated_node.params.with_changes(params=new_params)
        )

# This function applies a type annotation to a parameter
def annotate_parameter(filename, function, parameter, annotation) -> None:
    with open(filename, "r") as f:
        code = f.read()
    module = cst.parse_module(code)
    transformer = MethodAnnotator(function, parameter, annotation)
    modified_module = module.visit(transformer)
    with open(filename, "w") as f:
        f.write(modified_module.code)


# This function applies a type annotation to a return
def annotate_return(filename, function, annotation) -> None:
    with open(filename, "r") as f:
        code = f.read()
    module = cst.parse_module(code)
    transformer = MethodAnnotator(function, None, annotation)
    modified_module = module.visit(transformer)
    with open(filename, "w") as f:
        f.write(modified_module.code)


# This function gets the type of a parameter from the docstring
# The extracted type might not be a legal type annotatation
def extract_param_type(docstring: str, param: str) -> str | None:
    if not docstring:
        return None
    lines = docstring.splitlines()
    try:
        start = lines.index("Parameters")
    except ValueError:
        return None
    # Look for "----------" after "Parameters"
    for i in range(start + 1, len(lines)):
        if re.match(r'^-+$', lines[i].strip()):
            param_start = i + 1
            break
    else:
        return None
    param_pattern = re.compile(rf'^{re.escape(param)}\s*:\s*(.+)$')
    for i in range(param_start, len(lines)):
        line = lines[i].strip()
        if not line:
            continue
        if re.match(r'^[A-Za-z_][A-Za-z0-9_]*\s*:', line):  # new param starts
            match = param_pattern.match(line)
            if match:
                matched = match.group(1).strip()
                return matched
        elif line.startswith(('See Also', 'Notes', 'Examples')):
            break  # past parameter section
    return None


# This function gets the type of a function return from the docstring
# The extracted type might not be a legal type annotatation
def extract_return_type(docstring: str) -> str | None:
    if not docstring:
        return None
    lines = docstring.splitlines()
    try:
        start = lines.index("Returns")
    except ValueError:
        return None
    # Look for "----------" after "Returns"
    for i in range(start + 1, len(lines)):
        if re.match(r'^-+$', lines[i].strip()):
            return_line = i + 1
            break
    else:
        return None
    # Extract the first non-empty, non-indented line after the dashed line
    for i in range(return_line, len(lines)):
        line = lines[i]
        if line.strip() == "":
            continue
        if not line.startswith(" "):  # likely the type line
            return line.strip()
        else:
            break  # Weâ€™ve passed the expected return type line
    return None


# This function gets the docstring for a particular function
def get_docstring(mod: str, func: str) -> str | None:
    try:
        module = importlib.import_module(mod)
        if '.' in func:
            cls_name, method_name = func.split('.', 1)
            cls = getattr(module, cls_name, None)
            if cls is None:
                return None
            obj = getattr(cls, method_name, None)
        else:
            obj = getattr(module, func, None)
        if obj is None:
            return None
        return inspect.getdoc(obj)
    except Exception as e:
        print(e)
        return None


def get_module_path(root: str, file_path: str) -> str:
    rel_path = os.path.relpath(file_path, root)
    no_ext = os.path.splitext(rel_path)[0]
    return no_ext.replace(os.path.sep, '.')


def process_function(module: str, class_name: str | None, func_node: ast.FunctionDef, pkg_name) -> None:
    if func_node.name.startswith('__') and func_node.name.endswith('__'):
        return
    func_name = f"{class_name}.{func_node.name}" if class_name else func_node.name
    docstring = get_docstring(f"{pkg_name}.{module}", func_name)
    if docstring is None:
        return
    module_path = root + "/" + module.replace(".", "/") + ".pyi"
    global types
    for arg in func_node.args.args:
        if arg.arg in {'self', 'cls'}:
            continue
        if arg.annotation is None:
            arg_type = extract_param_type(docstring, arg.arg)
            if arg_type is None:
                continue
            arg_type = filter_type_annotation(arg_type)
            if arg_type is None:
                continue
            annotate_parameter(module_path, func_name, arg.arg, arg_type)
            types.add(arg_type)
    if func_node.returns is None:
        ret_type = extract_return_type(docstring)
        if ret_type is None:
            return
        if " : " in ret_type:
            ret_type = ret_type.split(" : ")[-1]
        ret_type = filter_type_annotation(ret_type)
        if ret_type is None:
            return
        annotate_return(module_path, func_name, ret_type)
        types.add(ret_type)


# Is this function decorated w/ @overload
def is_overload(func: ast.FunctionDef) -> bool:
    for decorator in func.decorator_list:
        if isinstance(decorator, ast.Name) and decorator.id == 'overload':
            return True
        if isinstance(decorator, ast.Attribute) and decorator.attr == 'overload':
            return True
    return False


def process_file(root: str, file_path: str, pkg_name) -> None:
    module = get_module_path(root, file_path)
    with open(file_path, "r", encoding="utf-8") as f:
        try:
            tree = ast.parse(f.read(), filename=file_path)
        except SyntaxError:
            return
    for node in tree.body:
        if isinstance(node, ast.FunctionDef):
            if is_overload(node):
                continue
            process_function(module, None, node, pkg_name)
        elif isinstance(node, ast.ClassDef):
            for item in node.body:
                if isinstance(item, ast.FunctionDef):
                    if is_overload(item):
                        continue
                    process_function(module, node.name, item, pkg_name)


def walk_directory(root: str, pkg_name: str) -> None:
    for dirpath, _, filenames in os.walk(root):
        for filename in filenames:
            if filename.endswith(".pyi"):
                process_file(root, os.path.join(dirpath, filename), pkg_name)


# Instructions:
# 1. clone pandas-stubs
# 2. install pandas
# 3. python3 extract_and_apply_annotations.py ./pandas-stubs/pandas-stubs pandas
if __name__ == "__main__":
    root = sys.argv[1]
    walk_directory(sys.argv[1], sys.argv[2])
